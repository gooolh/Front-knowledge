## 事件机制

- ### 事件冒泡

  事件从目标节点开始触发，一直向上传播，除非在执行停止冒泡，不然会一直传播到document对象

- ### 事件捕获

  捕获与事件冒泡相反，它是从document开发触发，一直传播到目标节点，可通过addEventListener的第三个参数控制事件类型，true则为捕获事件，反之是冒泡事件，当同时存在事件捕获和事件冒泡的情况下，document往目标节点，捕获前进，遇到注册的捕获事件立刻触发执行，到达目标节点，触发事件，（对于目标节点上事件的执行的顺序，是注册的顺序执行的），然后目标节点玩document方向，冒泡前进，遇到注册的冒泡事件立即触发

- 事件代理
  利用事件冒泡的机制，我们只需在父节点绑定一个事件处理函数，好处：不用每个子节点都绑定事件，也不用给每个子节点注销事件

## 从输入URL到页面呈现发生了什么？

### 网络请求

1. 首先是DNS查询，DNS查询的作用是找到具体的IP，因为IP是有数字和字母组成（IPV6），不利于人们的记忆，于是出现了域名，可以说域名是IP的别名，而DNS就是查询这个别名的真实昵称是什么，
2. 接下来是TCP握手，应用层会下发数据到传输层，这里TCP协议会指明两端的端口号，然后下发给网络层。网络层中的IP协议会确认IP地址，并且指示数据传输中如何跳转路由器，然后包会再被封装到数据链路层的数据帧结构中，最后就是物理层面的传输了
3. 数据进入服务端之前，可能还会经过负责负载均衡的服务器，它的作用就是将请求合理分发到多台服务器上，假设服务器会响应一个HTML文件，
4. 首先浏览器会判断状态码是什么，如果是200那就继续解析，如果是400或者500的话就会报错，如果是300的话会进行重定向，
   浏览器开始解析文件，如果是gzip格式的话会先解压一下，然后通过文件的编码格式就知道该如何去解析文件。
5. 文件解码完成后，开始渲染流程，先会根据HTML构建DOM树，有css的话会构建CSSOM树，如果遇到scipt标签的话，会判断是否存在async或者defer,前者会并行下载并执行js,后者则会先下载文件，然后等待HTML解析完成后顺序执行。如果以上都没有，就会阻塞住渲染流程直到JS执行完毕，遇到文件下载的会去下载文件，这里如果使用 HTTP/2 协议的话会极大的提高多图的下载效率。

注意：

- UI渲染线程和JavaScript是互阻的，因为javaScript可能会操控dom元素，UI渲染线程需要等待它执行完毕后才运行， 解析到script会阻塞dom的解析，从而阻碍dom树的建立，如果请求的js文件文件过大，就会出现白屏时间太久，影响用户的体验，建议把javaScirpt放在尾部，防止白屏的出现，script可使用defer属性。
- css是异步请求的，并不会影响dom的解析，建议放在头部，但是它会影响渲染树的构建，因为需要等待css请求完成后，构建最终的cssom树，放到尾部也可能会出现白屏现象。

## 浏览器的渲染过程

1. 解析HTML，生成DOM树，解析CSS，生成CSSOM树
2. 将DOM树和CSSOM树结合，生成渲染树（render Tree），这里并不是简单的合成，渲染树只会包括需要显示的节点和这些节点的样式信息，如果某个节点是`display:none`，则不会在渲染树里面
3. 构建完渲染树后，会根据渲染树进行布局（也可以叫做回流）Layout(回流)，得到节点的几何信息（位置和大小）
4. Painting(重绘):根据渲染树以及回流得到的几何信息，得到节点的绝对像素
5. Display:将像素发送给GPU，展示在页面上

## reflow(回流)

前面我们通过构造渲染树，我们将可见的节点以及的对应样式结合起来，此外我们还需要计算它们在设备视口（viewport）的位置和大小

指的是页面再次构建render树，每个页面至少发生一次回流，就是第一次加载网页的时候

触发条件

- 添加或者删除dom元素
- DOM节点发生 增减或移动时
- 元素的位置发生改变
- 元素的尺寸改变 ，比如说 `width` `height` `border` `margin` `padding`
- 读写 `offset`族、`scroll`族和`client`族属性的时候，浏览器为了获取这些值，需要进行回流操作。

回流过程：由于DOM的结构发生了改变，所以需要从生成DOM这一步开始，重新经过`样式计算`、`生成布局树`、`建立图层树`、再到`生成绘制列表`以及之后的显示器显示这整一个渲染过程走一遍，开销是非常大的。

## 重绘

重绘是当节点改变了改变了外观而不影响布局的情况下，不如改变了`color`就叫做重绘

需要将渲染树的每个节点转换转换为转换为实际像素

触发条件：

当 DOM 的修改导致了样式的变化，并且没有影响几何属性的时候，会导致`重绘`(`repaint`)。

重绘过程

跳过了`生成布局树`和`建图层树`的阶段，直接生成绘制列表，然后继续进行分块、生成位图等后面一系列操作。

可以看到，重绘不一定导致回流，但回流一定发生了重绘。

## CSRF 

CSRF跨站点请求伪造(Cross—Site Request Forgery)，跟XSS攻击一样，存在巨大的危害性，你可以这样来理解：

攻击者冒用别人的身份，以别人的名义发送请求，对服务器来说这个请求是合法的。

攻击原理：

1. 用户打开网站A，输入用户名和密码请求登陆网站A，验证成功后，网站A会返回cookie给浏览器，此时用户可以在网站A上进行操作。
2. 用户未退出网站A，在同一浏览器上，打开了一个新的页面网站B
3. 网站B带有攻击性的代码，在用户不知情的情况下请求A网站，比如说自己发送GET 请求，自动发送POST请求，这些会都是根据该用户的Cookie信息以用户的权限处理该请求。

处理办法

- 验证HTTP请求头 reader字段，优点：代码容易实现，缺点：referer是浏览器提供的，如果浏览器有漏洞，没有安全保障。

- 恰好，在 Cookie 当中有一个关键的字段，可以对请求中 Cookie 的携带作一些限制，这个字段就是`SameSite`。有三个值

  `Strict` 严格模式 只有在用一个站点才携带cookie 但是如果跳转的链接是需要cookie的，会导致未登录的情况，比如说跳转到Github 
  `Lax` 规则松一些，可以使用get表单，a标签 预加载 `link` 标签

  none  也就是默认模式，请求会自动携带上 Cookie。

- 在HTPP 请求头 加入自定义属性并验证，

## XSS

XSS跨站脚本攻击

它会通过合法的操作（比如在url中输入、在评论框中输入），向你的页面注入脚本（可能是js、hmtl代码块等）。

破坏网页的结构，盗取cookie，插入广告等

XSS的攻击方式

- 反射型	发出请求时，XSS代码出现在url中，作为输入提交到服务器端，服务器端解析后响应，XSS代码随响应内容一起传回给浏览器，最后浏览器解析执行XSS代码。这个过程像一次反射，所以叫反射型XSS。
- 存储型存   储型XSS和反射型XSS的差别在于，提交的代码会存储在服务器端（数据库、内存、文件系统等），下次请求时目标页面时不用再提交XSS代码。
- DOM型   攻击者构造出特殊的 URL，其中包含恶意代码。浏览器接收响应后解析执行，javaScript取出恶意代码并执行

DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。

处理方法

- 所有要插入到页面上的数据，都要通过一个敏感字符过滤函数的转义，过滤掉通用的敏感字符后，就可以插入到页面中。
- HTTP-only Cookie: 禁止 JavaScript 读取某些敏感 Cookie，攻击者完成 XSS 注入后也无法窃取此 Cookie。
- 利用CSP, 内容安全策略，能够决定浏览器能够加载哪些内容

## 强缓存和协商缓存

缓冲的优点

- 减少了不必要的数据传输，减少了服务器的压力
- 加快了客户端加载的速度
- 用户体验友好

缺点

资源如果有更改但是客户端不及时的更新会造成用户获取信息滞后，如果版本有bug的话，情况就会更加糟糕

所以，为了避免设置缓冲错误，掌握缓存的原理对于在工作中配置缓存是非常重要的

### 强缓存

顾名思义 强制缓存，如果请求某个文件的时候，服务端就在respone header里面对该文件做缓存配置。

cache-control字段 常见的设置是max-age public private no-cache no-store immutable等

- max-age=x  //x为缓存时间 单位 秒
- public   //表示可以被浏览器和代理服务器缓存
- private   //只让客户端可以缓存该资源；代理服务器不缓存
- no-cache  //跳过设置强缓存，但是不妨碍设置协商缓存；一般如果你做了强缓存，只有在强缓存失效了才走协商缓存的，设置了no-cache就不会走强缓存了，每次请求都回询问服务端。
- no-store   //不缓存，这个会让客户端、服务器都不缓存，也就没有所谓的强缓存、协商缓存了。
- immutable  //表示该资源永远不变  如果设置了这个属性  浏览器按刷新时，也不会发起请求去服务

发请求-->看资源是否过期-->未过期->200状态码->从浏览器读取缓存

如果过期的话会走协商缓存这流程。

### 协商缓存

协商 是客户端和服务端之间的协商，上面的强缓存是在客户端上的，协商缓存就是需要客户端和服务器两端进行交互的。

如何设置协商

```
response header设置这个两个字段
etag:xxx
last-modified:
```

etag: 每个文件唯一的hash，每个文件都不一样。

last-modified：文件的修改时间，精确到秒。

浏览器第一次请求数据根据 response header里面中获取的 etag和 last-modifie，在下一次请求 header将这个值带上，注意在request header中 etag字段会变为if-none-matched last-modifie 变为if-modified-since

发请求-->看资源是否过期-->过期-->请求服务器-->服务器对比资源是否真的过期-->过期-->返回200状态码-->客户端如第一次接收该资源一样，记下它的cache-control中的max-age、etag、last-modified等。

发请求-->看资源是否过期-->过期-->请求服务器-->服务器对比资源是否真的过期-->未过期-->返回304状态码->从浏览器读取缓存

### 简述的回答

浏览器缓存分为强缓存和协商缓存缓存，强缓存是通过http头部expires和cache-control所控制的，expires它是http1.0标准下的，表示缓存的过期时间，他有个缺陷，如果客户端时间和服务端时间不同步的话，会导致缓存失效，为了解决这个问题，http1.1提出的cache-control，它的功能丰富，常用的配置有，cache-control：public max-age=x秒，public 表示可以被客户端和代理服务器所缓存，max-age表示缓存在x秒后过期，

协商缓存是当强缓存失效的时候，协商的意思需要和服务端商量，来决定缓存是否继续可用，浏览器第一次请求数据时，服务端会将缓存标识和数据返回给客户端，再次请求的时候，客户端会将缓存标识发送给服务端，服务端根据标识，判断缓存是否失效，如果未过期，则返回304给浏览器，代表可以继续缓存。缓存标识有：last-modified和etag，last-modified表示资源的最后修改时间，再次发送请求时，请求头会带上if-modified-since,给服务端，etag是资源在服务器生成的唯一标识，生成规则由服务所控制，

## 跨域

跨域是因为浏览器的同源策略,同源策略是浏览器的一个安全功能，不同源且没有明确授权的情况下，不能读写对方的资源，不同源是当域名、协议、端口不一样。

解决方案：

1. jsoup是利用script标签引入资源没有限制的情况，缺陷也很明显，只支持get请求
2. 使用中间件代理，如使用nginx,tomcat
3. 利用CORS的机制，前提是浏览器支持这个功能和服务端也必须同意这种`跨域`请求，cors分为简单请求，和非简单请求，简单请求只能使用 get  post ，header 的content-type也收到限制，不能自定义请求头，而非简单就是除了简单请求的拉，需要发送一次预请求，以获知服务器是否允许该请求，

## Cookie、localstorage、seesionStroage

http它是一个无状态的协议，每次http请求都是独立，默认不需要保存用户状态的，如果需要保存一些状态，我们可以使用cookie,cookie是以键值对存储的，它的存储大小只有4kb，cookie是紧跟域名的，每当发送http都会携带cookie发送给服务端，一般用来保存用户的状态，如果使用不当，可能会引起安全的问题，如果xss和csrf

localstorage是持久化保存的一种方案，大小为5mb,不参与服务端通信，如果不主动删除，它会一直存在的，

seesionStroage它是会话级别的存储，也就是当浏览器关闭的时候seesionStroage它就会失效。

## 什么是SEO?

搜索引擎优化.通过各种技术来确保Web内容被搜索引擎最大化收录,最大化提高权重,带来更多流量.
1.对网站的标题、关键字、描述精心设置,反映网站的定位,让搜索引擎明白网站是做什么的;
2.网站内容优化:内容与关键字的对应,增加关键字的密度;
3.在网站上合理设置Robot.txt文件;
4.生成针对搜索引擎友好的网站地图;
5.增加外部链接,到各个网站上宣传.