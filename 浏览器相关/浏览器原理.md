## 说一说从输入URL到页面呈现发生了什么？

### 网络请求

1. 构建请求

   ```
   // 请求方法是GET，路径为根路径，HTTP协议版本为1.1
   GET / HTTP/1.1
   ```

2. 查找强缓存 ，先检查强缓存，如果命中直接使用，否则进入下一步。

3. DNS解析 ，由于我们输入的是域名，而数据包是通过IP地址传给对方的，以此需要将域名解析成IP地址，浏览器提供了DNS数据缓存功能，如果一个域名已经解析过，那会把解析的结果缓存下来，下次处理直接走缓存，不需要经过DNS解析。如果不指定端口的话，默认采用的是80端口。

4. 建立TCP连接
   通过3次握手建立客户端与服务端之间的连接。
   进行数据传输，这里有一个重要的机制，发送将数据包拆成一个个小报，依次发送给接收方，接收方则组装成完整数据包。接收方接收单数据包后必须要发送方`确认`，如果发送方没有接收这个`确认`的消息，则判断数据包丢失,并重新发送一遍。

5. 发送HTTP请求
   现在`TCP连接`建立完毕，浏览器可以和服务器开始通信，开始发送HTTP请求，HTTP请求携带，**请求行**，**请求头**，如果是post请求会有**请求体**。





## 回流

触发条件

- 添加或者删除dom元素
- DOM节点发生 增减或移动时
- 元素的位置发生改变
- 元素的尺寸改变 ，比如说 `width` `height` `border` `margin` `padding`
- 读写 `offset`族、`scroll`族和`client`族属性的时候，浏览器为了获取这些值，需要进行回流操作。

回流过程：由于DOM的结构发生了改变，所以需要从生成DOM这一步开始，重新经过`样式计算`、`生成布局树`、`建立图层树`、再到`生成绘制列表`以及之后的显示器显示这整一个渲染过程走一遍，开销是非常大的。

## 重绘

触发条件：

当 DOM 的修改导致了样式的变化，并且没有影响几何属性的时候，会导致`重绘`(`repaint`)。

重绘过程

跳过了`生成布局树`和`建图层树`的阶段，直接生成绘制列表，然后继续进行分块、生成位图等后面一系列操作。

可以看到，重绘不一定导致回流，但回流一定发生了重绘。

## CSRF 

CSRF跨站点请求伪造(Cross—Site Request Forgery)，跟XSS攻击一样，存在巨大的危害性，你可以这样来理解：

攻击者冒用别人的身份，以别人的名义发送请求，对服务器来说这个请求是合法的。

攻击原理：

1. 用户打开网站A，输入用户名和密码请求登陆网站A，验证成功后，网站A会返回cookie给浏览器，此时用户可以在网站A上进行操作。
2. 用户未退出网站A，在同一浏览器上，打开了一个新的页面网站B
3. 网站B带有攻击性的代码，在用户不知情的情况下请求A网站，比如说自己发送GET 请求，自动发送POST请求，这些会都是根据该用户的Cookie信息以用户的权限处理该请求。

处理办法

- 验证HTTP请求头 reader字段，优点：代码容易实现，缺点：referer是浏览器提供的，如果浏览器有漏洞，没有安全保障。

- 恰好，在 Cookie 当中有一个关键的字段，可以对请求中 Cookie 的携带作一些限制，这个字段就是`SameSite`。有三个值

  `Strict` 严格模式 只有在用一个站点才携带cookie 但是如果跳转的链接是需要cookie的，会导致未登录的情况，比如说跳转到Github 
  `Lax` 规则松一些，可以使用get表单，a标签 预加载 `link` 标签

  none  也就是默认模式，请求会自动携带上 Cookie。

- 在HTPP 请求头 加入自定义属性并验证，

## XSS

XSS跨站脚本攻击

它会通过合法的操作（比如在url中输入、在评论框中输入），向你的页面注入脚本（可能是js、hmtl代码块等）。

破坏网页的结构，盗取cookie，插入广告等

XSS的攻击方式

- 反射型	发出请求时，XSS代码出现在url中，作为输入提交到服务器端，服务器端解析后响应，XSS代码随响应内容一起传回给浏览器，最后浏览器解析执行XSS代码。这个过程像一次反射，所以叫反射型XSS。
- 存储型存   储型XSS和反射型XSS的差别在于，提交的代码会存储在服务器端（数据库、内存、文件系统等），下次请求时目标页面时不用再提交XSS代码。
- DOM型   攻击者构造出特殊的 URL，其中包含恶意代码。浏览器接收响应后解析执行，javaScript取出恶意代码并执行

DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。

处理方法

- 所有要插入到页面上的数据，都要通过一个敏感字符过滤函数的转义，过滤掉通用的敏感字符后，就可以插入到页面中。
- HTTP-only Cookie: 禁止 JavaScript 读取某些敏感 Cookie，攻击者完成 XSS 注入后也无法窃取此 Cookie。

## 强缓存和协商缓存

缓冲的优点

- 减少了不必要的数据传输，减少了服务器的压力
- 加快了客户端加载的速度
- 用户体验友好

缺点

资源如果有更改但是客户端不及时的更新会造成用户获取信息滞后，如果版本有bug的话，情况就会更加糟糕

所以，为了避免设置缓冲错误，掌握缓存的原理对于在工作中配置缓存是非常重要的

### 强缓存

顾名思义 强制缓存，如果请求某个文件的时候，服务端就在respone header里面对该文件做缓存配置。

cache-control字段 常见的设置是max-age public private no-cache no-store immutable等

- max-age=x  //x为缓存时间 单位 秒
- public   //表示可以被浏览器和代理服务器缓存
- private   //只让客户端可以缓存该资源；代理服务器不缓存
- no-cache  //跳过设置强缓存，但是不妨碍设置协商缓存；一般如果你做了强缓存，只有在强缓存失效了才走协商缓存的，设置了no-cache就不会走强缓存了，每次请求都回询问服务端。
- no-store   //不缓存，这个会让客户端、服务器都不缓存，也就没有所谓的强缓存、协商缓存了。
- immutable  //表示该资源永远不变  如果设置了这个属性  浏览器按刷新时，也不会发起请求去服务

发请求-->看资源是否过期-->未过期->200状态码->从浏览器读取缓存

如果过期的话会走协商缓存这流程。

### 协商缓存

协商 是客户端和服务端之间的协商，上面的强缓存是在客户端上的，协商缓存就是需要客户端和服务器两端进行交互的。

如何设置协商

```
response header设置这个两个字段
etag:xxx
last-modified:
```

etag: 每个文件唯一的hash，每个文件都不一样。

last-modified：文件的修改时间，精确到秒。

浏览器第一次请求数据根据 response header里面中获取的 etag和 last-modifie，在下一次请求 header将这个值带上，注意在request header中 etag字段会变为if-none-matched last-modifie 变为if-modified-since

发请求-->看资源是否过期-->过期-->请求服务器-->服务器对比资源是否真的过期-->过期-->返回200状态码-->客户端如第一次接收该资源一样，记下它的cache-control中的max-age、etag、last-modified等。

发请求-->看资源是否过期-->过期-->请求服务器-->服务器对比资源是否真的过期-->未过期-->返回304状态码->从浏览器读取缓存

