## 计算机网络

### 三次握手

1. 第一次握手：客户端发送SYN报文，报文含有seq=x x为一个随机生成的数，此时处于SYN_SENT状态
2. 第二次握手：服务端收到客户端的SYN报文之后，会发送SYN+AKC报文，且把客户端发送的序列号+1，作为ACK的值，同时也会生成一个随机数Y作为seq的值，此时处于SYN_RCVD状态
3. 第三次握手：客户端收到SYN+ACK报文后，会发送一个发送ACK报文，当然会将客户端的seq+1作为自己ack的值，发送后，客户端处于ESTABLISHED状态，三次握手到这就结束了

为什么需要三次握手

- 为了保证双方都有接收和发送的功能，比如客户端第一次发送请求，因为网络延迟的原因，没有到达，而后又重新发了一次请求，建立了连接，之后第一次请求又到达了服务器，也建立了连接，会造成服务端资源的损耗

### 四次挥手

客户端和服务端都可以发起断开连接的请求，这里以客户端为例子

1. 第一次挥手：client发送FIN报文  报文含有随机生成数x作为序列号seq的值，此时处于FIN_WAIT,并停止发送数据，等待server的确认
2. 第二次挥手：server收到FIN报文后，会发送ACK报文，且把client发送的序列号+1，作为ack的序列号的值， ack=x+1，同时也会生成一个随机数Y作为seq的值给client，此时处于CLOSE_WAIT状态
3. 第三次挥手：等待servers发生完数据后，和client一样发送FIN报文给client  此时处于LAST_ACK状态
4. 第四次挥手：client收到FIN后，一样发送一个ACK报文作为应答，把server的序列号值+1作为自己ack的值，此时处于TIME_WAIT状态，此时TCP还没有释放掉，需要等待2MSL后，客户端才进入CLOSED状态

为什么需要四次挥手：

- 当服务器收到FIN报文时，会先回复一个ACK报文，告诉客户端，你的FIN报文我已经收到了，只有当服务器所有的报文都发送完,才发送FIN报文，因此不能一起发送，故需要四次挥手

2MSL等待的意义

- MSL(最长报文段寿命)，它是任务报文网络上存在的最长时间，超过这个时间报文将被抛弃，MSL可能是30s、1min，
- 保证服务端能够收到客户端最后发送的ACK报文，如果没有到达，服务端则会超时重传FIN报文，使得客户端、服务端都正常进入关闭状态
- 防止已失效的连接请求报文段出现在本连接中，这样就可以便于下一个新的连接中不会出现旧的连接请求报文段。

## HTTP

GEH和POST的区别

```
从缓存的角度上说，GET会被浏览器主动缓存下来，留下历史记录，但是POST不会。
从参数的角度上说，GET一般放在URL上传递参数，POST放在请求体里，更适合传递敏感信息。
从编码的角度上说，GET只能进行URL编码，它只能接收ASCII字符，但是POST没有限制。所以说GET不能上传图片
从性能的角度上说，GET性能比较高，因为GET可以触发缓冲，POST会发送2次数据包，第一次是发送header,服务端响应100，浏览器在发送data，然后服务端返回200
```

请求行

```
//请求协议  请求路径  使用的http版本
GET /index http1.1
```

请求头

```
常见的请求头
Host	接收请求的服务器地址
User-Agent	发送请求的应用程序名称
Connection	指定连接的相关熟悉，如Connection:Keep-Alive
Accept-Charset	通知服务端可以发送的编码格式
Accept-Encoding 	通知服务端可以发送的数据压缩格式
Accept-Language 	通知服务端可以发送的语言

//keep-Alive
//作用是建立长连接， 建立一次TCP请求即可发送多次HTTP请求。
```

状态码

```
常见的状态码
200		请求成功
301		永久重定向
302		临时重定向
304		通知浏览器资源没有更新
400		请求的参数不合适
403		客户端禁止访问
404		资源没有找到
500		服务端错误
503		暂时无法访问服务器

301和302的区别是什么？
首先301是永久重定向，302是临时重定向
共同的：浏览器收到服务器返回的某个状态会自动跳转到一个新的url地址，这个地址从响应头中获取，用户看到他输入的地址会瞬间变成了另一个地址
不同点：301表示旧的地址已经永久地被移除了，搜索引擎在抓取新内容时也将旧的网址交换为重定向之后的网址，302表示旧的地址资源还在，只不过临时转到其他去了，搜索引擎会抓取新的内容保存到旧的网址，比如说进入到一个个人用户页，当session过期了，会被登陆到登陆页，这是一个302跳转。
```

响应头

```
常见的响应头
Content-Type	响应的正文内容类型（图片或者html）
Content-Length	响应正文的长度
Content-charset	响应正文的编码格式
Content-Encoding	响应正文使用的数据压缩格式
Content-language	响应正文使用的语言
```

### HTTP：

HTTP 无状态也就是说没有记忆功能，每一个URL都是独立的，但是我们常常需要通过某种途径来保存状态，我们可以使用cookie/seesion的方式来保存状态

### HTTPS：

由于HTTP它是明文传输数据的，在传输过程中，可能会出现修改或者伪造请求、响应报文、数据可具有可信性，为了解决这个安全的问题，引入HTTPS，

HTTPS其实是HTTP和SSL/TLS的组合，HTTPS 使用了对称加密和非对称加密的混合加密方式，发送密文的一方 利用公钥将对称密钥进行加密处理，然后发送给服务端，然后对方在收到之后使用自己的私钥进行界解码 获得对称密钥，这个过程简单来说：

1. 客户端发送一个HTTPS请求
2. 服务端将事先配置好的公钥证书随其他信息返回给客户端
3. 客户端在收到证书之后，进行验证，会得到服务端的信息以及公钥
4. 验证成功之后会用**伪随机函数**计算出一个加密所需要的对称密钥(secret)，并且用服务端的公钥加密这个对称密钥发送给服务端
5. 服务端收到后再用自己私钥解密刚刚的信息，得到里面的对称密钥，此时服务端和客户端都有对称密钥了
6. 后面的传输都会用这个密钥进行加密传输

### 数字证书

数字证书也叫公钥证书，它主要是为了解决通信方身份遭伪装的问题，也就是验证对方的身份

刚才说到HTTPS是混合加密机制的，但是不能确保这个公钥就是发送方的，有可能会遭到中间人攻击，将密钥进行篡改，为了保证公钥是可信赖的，所以需要数字证书。

它简单来说是权威的数字认证机构颁发给服务器的一个文件，数字认证机构简称：CA ,颁布认证的流程主要是

- 服务器运营人员向机构提交自己的公钥，还有一些组织信息、个人信息等申请
- 机构收到后会验证这些信息的真实性
- 验证通过后，会将提交的这些信息，进行数字签名
- 之后会将原来的提交信息和数字签名组合而成的证书颁布给申请者

### 数字签名

数字签名的为了解决HTTP中内容有可能被篡改，既验证数据的完整性，

数字签名的产生分为两步，第一步会用原文的信息会hash函数的处理，得到一份信息摘要，然后将发送方的私钥进行加密处理，生成数字签名，并将原文和数字签名发送给客户端。

验证的过程并不复杂

- 发送方将原文信息和数字签名给接收方
- 接收方会用hash函数处理原文得到一份信息摘要
- 同时会用浏览器自带的公钥解密数字签名也会得到一份信息摘要
- 比较两份信息摘要看是否相等，验证出数据是否被篡改



## DNS解析过程

- 当浏览器输入一个地址时，先查询浏览器器是否有缓存，有则返回ip地址，没有进入下一步
- 查询操作系统的hosts文件，看是否存在对应的域名和ip ，没有进入下一步
- 向本地域名服务器请求，这时一个递归查询的过程，查看本地域名服务器是否有缓冲，没有的话，本地域名服务器进行迭代查询
- 向根域名服务器进行查询，返回改域名的顶级域名服务器的地址，
- 本地域名服务器则发送请求到根域名服务器返回的地址，返回网站的域名服务器
- 然后本地域名则请求该域名所在的域名服务器，返回IP地址给浏览器
- 解析结束

### DNS 优化

1. 善用TTL值，DNS服务器中存在多处缓存，我们尽量在运营商的DNS缓存中拿到解析记录，不用向根域名服务器一层一层的去找，自然节省时间，TTL值，简单来说是解析记录在DNS服务器的缓存时间，对于不需要经常切换服务器，TTL的值可以写大一点，对于经常换服务器的来说，TTL越短切换得越及时。
2. DNS负载均衡，在DNS服务器中为一主机名配置多个ip地址，DNS服务器会主机记录得IP地址顺序返回不同的解析结果，从而使不同客户端访问不同的服务器，达到负载均衡的目的

## TCP

### 滑动窗口

​	TCP发送端会维护一个发送窗口，接收端会维护一个接收窗口。简单来说，发送窗口是允许发送的数据帧，每收到一个确认帧，发送窗口就会向前滑动一个帧的距离，当发送窗口内无可发送的数据时（窗口的数据帧已经发送过去，但未收到确认），发送方会停止发送。直到接收方收到确认帧，对于接收窗口，每接收到一个数据帧就会向前滑动，如果收到不是接收窗口的数据，则一律丢弃

### 重传协议ARQ

- 停止等待协议，就是发送每发送一个帧，要等待接收方的应答后才能发送下一帧，接收方每接收一个数据帧，都会反悔一个应答信号，表示可以接收下一帧，如果接收方不反馈信号，则发送发就会一直等待
- 连续ARQ协议：原理是多帧滑动窗口+累计确认+后退N帧+超时重传；发送方连续发送多个数据帧，而不需等待对方确认,从而大大提高了信道的利用率.并且它采用累积确认的方式,对于**按序**到达的最后一个分组发送确认.后退N帧是，当发送方发送N帧后，若发现该N个帧的前一帧未收到确认信息，则会重发之后的N个帧

### 流量控制

​	TCP的流量控制是利用滑动窗口机制，如果数据发送太快，接收方可能接收不到，这就造成了数据的丢失，流量控制就是上发送方的速率不要太快

### 拥堵控制

​	防止过多的数据拥入网络中，使得网络的路由器 链路过载

解决方案

- 慢开始 拥堵避免
  主要靠拥堵窗口、慢开始算法、拥堵避免算法
  拥堵窗口：发送方维护一个状态变量，根据自己估算的网络拥堵的程度而设置的值，它的大小取决于网络拥堵情况
  慢开始算法：当主机发送数据时，由小到大逐渐增大拥堵窗口的值，从而逐渐提高发送报文段
  拥堵避免算法：使拥堵窗口的值按线性增长，每经过一次往返，拥堵窗口就会`+1`
  拥堵控制的过程：初始化状态，有两个变量，一个是拥堵窗口和慢开始的门槛（使用慢开始算法的条件，拥堵窗口的值小于慢开始门槛），一开始会采用慢开始算法，到达门槛之后会采用拥堵控制算法，如果出现网络拥堵，则将拥堵窗口设为1，慢开始门槛设为之前拥堵窗口的值的一半，

- 快重传 快恢复

  

## TCP和UDP的区别

1. TCP是面向连接的，可靠的、基于字节流的传输层协议
2. UDP是面向无连接的的传输层协议
3. TCP的头部占用20个字节，UDP头部开销较小，只占用8个字节
4. TCP只支持点到点连接，UDP支持1对多和多对多的交互通信

### TCP的优点：

- 稳定可靠：TCP在传输数据之前，会有3次握手来建立连接，且在数据传递时，有序列号、确认应答、超时重传、流量控制，拥堵控制机制



### TCP的缺点：

- 占用系统资源高，机器需要维护所有的传输连接，每个连接都会占用资源
- 消耗时间较长，TCP在传递数据之前，要先建立连接，在传输时会有确认机制，重传机制，拥堵控制机制都会消耗时间

### UDP优点：

- 快

### UDP缺点：

- 不可靠、不稳定，如果网络质量不好，很容易发生丢包

一般对于网络通信质量有要求时，应该使用TCP，能保证数据准确无误的发送给对方，比如HTTP、FTP等协议，对于实时性较强的，应该使用UDP，比如通话、游戏之类的

## CDN原理

​	CDN 即内容分发网络，其目的是使用户就近取得所需内容，解决网络拥堵的状况，提高用户访问网站的响应速度。，它能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离等综合因素，重新导向里用户最近的服务节点上。

### 工作流程

1. 当用户点击网站页面上的内容URL，先经过本地DNS系统解析，如果本地DNS服务器没有相应域名的缓存，则本地DNS系统会将域名的解析权交给CNAME指向的CDN专用DNS服务器。
2. CDN的DNS服务器将CDN的全局负载均衡设备IP地址返回给用户。
3. 用户向CDN的全局负载均衡设备发起URL访问请求。
4. CDN全局负载均衡设备根据用户IP地址，以及用户请求的URL，选择一台用户所属区域的区域负载均衡设备，并将请求转发到此设备上。
5. 基于以下这些条件的综合分析之后，区域负载均衡设备会选择一个最优的缓存服务器节点，并从缓存服务器节点处得到缓存服务器的IP地址，最终将得到的IP地址返回给全局负载均衡设备：



## HTTP1.0和HTTP1.1和HTTP2.0和Http3.0

### HTTP1.0

​	HTTP1.0比较老的一种标准，只支持`get/post` ，连接无法复用，指的是每次请求都会经过3次握手，断开连接4次分手；队头阻塞是如果前面的请求没有完成，后面的请求会被阻塞

### HTTP1.1与HTTP1.0区别

**缓存处理**：HTTP1.0主要使用header里的expires、if-Modified-since来做为缓存判断的标准，http1.1则引入更多缓存策略catch-control、etag、

**长连接**：HTTP1.1支持长连接和管道请求（Pipelining）处理，在一个TCP请求可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，再HTTP1.1默认开启Connection：keep-alive，优化之前HTTP1.0每次请求都要创建连接的缺点

**增加host字段**：我知道1个ip地址可以对应多个域名，假如我有3个域名都映射对应同一个IP地址，想映射到我的不同的网站的话，这时候可以利用配置host字段作为标识，后台通过配置host,来实现3个域名对应同一个ip地址分别访问到不同的3个网址

**Chunked transfer-coding**：在http1.0 不支持长连接的时候，其实是可以依靠连接断开来判定当前传输已经结束，大部分浏览器也是这么干的，但这并不是规范的操作。应该使用 `Content-Length` 这个头部，来指定当前传输的实体内容长度。`Content-Length` 在这里起到了一个响应实体已经发送结束的判断依据。这样的情况下，我们就要求 `Content-Length` 必须和内容实体的长度一致，如果不一致，就会出现各种问题。HTTP新增一个新的机制来判定当前内容实体是否传输完成，此时就需要 `Transfer-Encoding` 这个头部来判定。

### HTTP/2

HTTP/2相比于HTTP/1，可以说大幅度提高了网页的性能

在HTTP/1中，为了性能考虑，我们会引入雪碧图，将小图内联、使用多个域名等等的方式。这是因为浏览器限制了同一个域名下的请求数量（chrome一般是限制六个连接），当页面中需要请求很多资源的时候，会出现队头阻塞（Head of line blocking）会导致在达到最大请求数量时，剩余的资源需要等待其他资源请求完成后才能发起请求。

HTTP/2中引入了多路复用的技术，这个技术可以只通过一个TCP就可以传输所有的请求数据，多路复用很好的解决了浏览器限制同意域名下的请求数量的问题

### 二进制传输

HTTP/2 加强性能的核心在于此，在之前的HTTP版本中，我们是通过文本的方式传输数据的，在HTTP/2引入了新的编码机制，所有传输的数据会将会采用二进制格式编码

### 多路复用

在HTTP/2 ,有两个重要的概念，分别是帧（frame）和流（stream）

帧代表最小的数据单位，每个帧会标识出该帧属于哪个流，流是多个帧组成的数据流，多路复用，就是在一个TCP连接存在多个流，通过帧的标识直到属于哪个请求，通过这个技术，可以解决HTTP旧版本的队头阻塞问题，提高传输性能。

### Header压缩

在HTTP/1中，我们使用文本的形式传输header,在header携带cookie的情况下，可能每次都需要传送几百或者几千个字节过去，

在HTTP/2中，使用了 HPACK 压缩格式对传输的 header 进行编码，减少了 header 的大小。并在两端维护了索引表，用于记录出现过的 header ，后面在传输过程中就可以传输已经记录过的 header 的键名，对端收到数据后就可以通过键名找到对应的值。

### 服务端PUSH

在 HTTP/2 中，服务端可以在客户端某个请求后，主动推送其他资源。

可以想象以下情况，某些资源客户端是一定会请求的，这时就可以采取服务端 push 的技术，提前给客户端推送必要的资源，这样就可以相对减少一点延迟时间。当然在浏览器兼容的情况下你也可以使用 prefetch 。

### HTTP/3

虽然 HTTP/2 解决了很多之前旧版本的问题，但是它还是存在一个巨大的问题，虽然这个问题并不是它本身造成的，而是底层支撑的 TCP 协议的问题。

因为 HTTP/2 使用了多路复用，一般来说同一域名下只需要使用一个 TCP 连接。当这个连接中出现了丢包的情况，那就会导致 HTTP/2 的表现情况反倒不如 HTTP/1 了。

因为在出现丢包的情况下，整个 TCP 都要开始等待重传，也就导致了后面的所有数据都被阻塞了。但是对于 HTTP/1 来说，可以开启多个 TCP 连接，出现这种情况反到只会影响其中一个连接，剩余的 TCP 连接还可以正常传输数据。

那么可能就会有人考虑到去修改 TCP 协议，其实这已经是一件不可能完成的任务了。因为 TCP 存在的时间实在太长，已经充斥在各种设备中，并且这个协议是由操作系统实现的，更新起来不大现实。

基于这个原因，Google 就更起炉灶搞了一个基于 UDP 协议的 QUIC 协议，并且使用在了 HTTP/3 上，当然 HTTP/3 之前名为 HTTP-over-QUIC，从这个名字中我们也可以发现，HTTP/3 最大的改造就是使用了 QUIC，接下来我们就来学习关于这个协议的内容。

### QUIC

之前我们学习过 UDP 协议的内容，知道这个协议虽然效率很高，但是并不是那么的可靠。QUIC 虽然基于 UDP，但是在原本的基础上新增了很多功能，比如多路复用、0-RTT、使用 TLS1.3 加密、流量控制、有序交付、重传等等功能。这里我们就挑选几个重要的功能学习下这个协议的内容。

**多路复用**

虽然 HTTP/2 支持了多路复用，但是 TCP 协议终究是没有这个功能的。QUIC 原生就实现了这个功能，并且传输的单个数据流可以保证有序交付且不会影响其他的数据流，这样的技术就解决了之前 TCP 存在的问题。

并且 QUIC 在移动端的表现也会比 TCP 好。因为 TCP 是基于 IP 和端口去识别连接的，这种方式在多变的移动端网络环境下是很脆弱的。但是 QUIC 是通过 ID 的方式去识别一个连接，不管你网络环境如何变化，只要 ID 不变，就能迅速重连上。

**0-RTT**

通过使用类似 TCP 快速打开的技术，缓存当前会话的上下文，在下次恢复会话的时候，只需要将之前的缓存传递给服务端验证通过就可以进行传输了。

**纠错机制**

假如说这次我要发送三个包，那么协议会算出这三个包的异或值并单独发出一个校验包，也就是总共发出了四个包。

当出现其中的非校验包丢包的情况时，可以通过另外三个包计算出丢失的数据包的内容。

当然这种技术只能使用在丢失一个包的情况下，如果出现丢失多个包就不能使用纠错机制了，只能使用重传的方式了。

### 小结

总结一下内容：

- HTTP/2 通过多路复用、二进制流、Header 压缩等等技术，极大地提高了性能，但是还是存在着问题的
- QUIC 基于 UDP 实现，是 HTTP/3 中的底层支撑协议，该协议基于 UDP，又取了 TCP 中的精华，实现了即快又可靠的协议





