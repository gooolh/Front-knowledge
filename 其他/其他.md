## 大文件上传

### 前端

核心是利用`blob.prototype.slice`方法进行切片，这样我们将大文件进行切片得到了许多小文件，然后利用http的并发性，同时上传多个切片,减少上传时间，由于是并发，传到服务器可能顺序会不一样，还要给每个切片添加一个序号。

断点续传的原理在于前端或者服务端需要**记住**已经上传的切片，这样下次上传就可以跳过之前上传的部分，前端和服务器都可以保存已上传的切片，前端的话可以使用localStoreage，服务器保存上传的hash,可以采用后端保存的方式，因为前端如果换了浏览器就没有记忆的效果了，我们要对文件一个hash,这样如果文件内容不变，hash就不会变了，生成hash值得时间可能比较慢，引起UI界面得阻塞，我采用了web woker，将hash计算分给一个后台线程。

暂停上传原理是使用 XMLHttpRequest 的 `abort` 方法，可以取消一个 xhr 请求的发送

恢复上传，我们是采用服务器保存hash的，我们上传前请求获取已经上传的hash值，这样可以跳过已经上传的切片了

### 服务端

核心在于处理何时合并切片，我们上传完成时，我们发送一个请求通知服务器进行合并



## 服务器渲染SSR

客户端请求服务器时，服务器内部会将数据和组件的渲染成HTML，然后返回这个HTML数据，服务器渲染，对于浏览器来说只是解析HTML，而之前的SPA项目，返回的是一个html的空壳，需要执行js后才生成最后的内容。它的本质是字符串的拼接，利用虚拟dom节点翻译成真实的DOM

优点：

有利于SEO

减少白屏时间：浏览器直接得到HTML文件，进行解析，不需要再请求后台服务器

缺点：

增加了服务器的压力，相比之前只返回静态文件，现在还需要渲染HTML的情况

还有部署的时候，还需要有node的环境



## 计算白屏时间和首屏时间

​	白屏时间=页面开始显示节点的时间-开始请求的时间点

开始请求时间可以通过performance Timing.navgation.start获取，页面开始显示节点的时间可以当作开始解析body节点的时间，可以通过插入head标签末，也可以通过performance Timing.dom Loading获取

​	首屏时间=首屏渲染结束的时间-开始请求的时间点

开始请求的时间点同样用performance Timing.navgation.start获取，首屏渲染时间有几种方式获取

1. 首屏模块标签标记法
   适用于首屏不需要拉取数据以及不考虑图片等资源加载的情况，通过首屏内容标签末尾插入内联javaScript代码记录当前时间点
2. 统计首屏内加载最慢的图片的时间
   通常首屏内容加密最慢的就是图片资源，因此可以把最慢图片加载完成的时间点作为首屏时间
3. 自定义首屏内容计算
   由于统计首屏的图片完成加载的时间比较复杂，我们可以只考虑主要模块作为计算点，而不是全部内容。

## 0.1+0.2不等于0.3

计算机都是二进制存储数据的，js 中的Number类型，它是使用IEEE 754 双精度64位浮点数表示的，0.1 二进制无法精确的表示，当超出位数时，会进行截取，实际相加的大小会比0.3大,凡是采用IEEE 754 双精度存储的编程语言都会出现这个问题

解决方法：

- 可以使用`toFixed` 方法进行保留小数位数
- 使用 `Number.EPSILON` 表示误差范围 ，可以在这个误差范围内，我们都可以认为它是正确的

## 金额每 3 位进行分隔

```javascript
// 德国以 . 分割金钱, 转到德国当地格式化方案即可
10000000000..toLocaleString('de-DE') 

// 寻找字符空隙加 .
'10000000000'.replace(/\B(?=(\d{3})+(?!\d))/g, '.')

// 寻找数字并在其后面加 . 
'10000000000'.replace(/(\d)(?=(\d{3})+\b)/g, '$1.')
```

