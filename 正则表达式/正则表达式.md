# 正则表达式

### 元字符

1. .匹配除换行符以外的任意字符
2. \w  (word)匹配字符或数字或下划线或汉字
3. \s   (space)匹配任意的空格
4. \d   (digit)匹配数字
5. \b   (begin)匹配单词的开始或结束
6. ^   匹配字符串的开始
7. $   匹配字符串的结束

例子：

- 匹配abc开头  

  ```
  ^abc 
  ```

  

-  匹配 13开头的11位手机号 

  ```
  ^13\d\d\d\d\d\d\d\d\d$
  ```

  

### 重复限定符

1. *&nbsp;重复0次或多次
2. +&nbsp;重复1次或多次
3. ? 重复0次或一次
4. {n} 重复n次
5. {n,} 重复n次到多次
6. {n,m} 重复n次到m次

例子

- 匹配9位数QQ号	

  ```
  ^\d{9}$
  ```

  

- 匹配1开头11位手机号    

  ```
  ^1\d{10}$
  ```

  

- 匹配以a开头的，0个或多个b结尾的字符串    

  ```
  ^ab*$
  ```

  

### 分组

1. 重复限定符只能限制左边的一个字符，如果我们想限制多个字符 就要用到分组了
2. 正则表达式中使用() 表示分组

例子

- 匹配ab开头的字符串	

  ```
  ^(ab)*
  ```

  

### 转义

1. 如果我们要匹配 元字符 限定符和分组的符号 为了不发生冲突，就要用到转义了
2. 要转义的字符前面加上反斜杠 也就是 \ 即可

例子

- 匹配(ab)开头的字符串	

  ```
  ^(\(ab\))$
  ```

### 条件或

1. 正则用符号 | 来表示或，也叫做分支条件，当满足正则里的分支条件的任何一种条件时，都会当成是匹配成功。

例子

- 匹配131 132 133 134 等开头的手机号	^(131|132|133|134)\d{8}$

### 区间

1. 使用[n1-n2]表示n1到n2的区间条件，闭区间
2. [\da-z]   代表数字和小写字母a到z

例子

- 匹配131 132 133 134 等开头的手机号	^(13[1-4])\d{8}$

### 零宽断言

1. 断言  指的是满足规定规则内容  零宽 表示返回结果不包含规则本身
2. 正向先行断言 (正前瞻)   规则：(?=pattern)   //往前面去找
3. 正向后行断言 (正后顾)  规则：(?<=pattern)   
4. 负向先行断言  "负向"指的是非得意思  (?!pattern)
5. 负向后行断言  (?<!pattern)

例子

- ```
  1. 标签<a>年龄: 18</a>  利用正则表达式找出年龄
  String reg="\\d*(?=</a>)"  //正向先行断言   >> 18
  String reg="(?<=<a>年龄:)\\d*"  //正向后行断言  >> 18
  2. 我爱祖国，我是祖国的花朵 
  String reg=".*祖国(?!的花朵)"  //负向先行断言 找到的不是"的花朵"前面的祖国  >> 我爱祖国
  String reg="(?<!我爱)祖国.*" //负向后向断言  找到的是不"我爱"后面的祖国  >>祖国的花朵
  
  ```

  

### 捕获和非捕获

1. 捕获组：匹配子表达式的内容，把匹配结果保存到内存中中数字编号或显示命名的组里，以深度优先进行编号，之后可以通过序号或名称来使用这些匹配结果。
2. 数字编号捕获组  语法(exp)  从表达式左侧开始，每出现一个左括号和它对应的右括号为一个分组，在分组中 第0组为整个表达式，第一组开始为分组
3. 命名编号捕获组  (?<name>exp)
4. 非捕获组  (?:exp)   解释：和捕获组刚好相反，它用来标识那些不需要捕获的分组，说的通俗一点，就是你可以根据需要去保存你的分组。 例子 (?:\0\d{2})-(\d{8})
5. 单纯说到捕获，他的意思是匹配表达式，但捕获通常和分组联系在一起，也就是“捕获组”

例子

- 比如固定电话的：020-85653333 他的正则表达式为：(0\d{2})-(\d{8})  它的分组为  

- | 序号 | 编号 |       分组       |     内容     |
  | :--: | :--: | :--------------: | :----------: |
  |  0   |  0   | （0\d{2}-(\d{8}) | 020-85653333 |
  |  1   |  1   |     (0\d{2})     |     020      |
  |  2   |  2   |     (\d{8})      |   85653333   |

  ```
  String test="020-85653333";
  String reg="(0\\d{2})-(\\d{8})";
  Pattern pattern=Pattern.compile(reg);
  Matcher mc=pattern.matcher(test);
  if(mc.find()){
  	System.out.println("分组的个数有："+mc.groupCount());
  	for (int i = 0; i <= mc.groupCount(); i++) {
  		System.out.println("第"+i+"个分组为："+mc.group(i));
  	}
  }
  
  分组的个数有：2
  第0个分组为：020-85653333
  第1个分组为：020
  第2个分组为：85653333
  ```

### 反向引用

1. 在正则表达式中，***捕获会返回一个捕获组，这个分组是保存在内存中，不仅可以在正则表达式外部通过程序进行引用，也可以在正则表达式内部进行引用，这种引用方式就是反向引用***。

2. 根据捕获组的命名规则，反向引用可分为：

   1. 数字编号组反向引用：\k
      或\number
   2. 命名编号组反向引用：\k
      或者\'name'

   例子

   - 比如要查找一串字母"aabbbbgbddesddfiid"里成对的字母

```
   String test = "aabbbbgbddesddfiid";
        Pattern pattern = Pattern.compile("(\\w)\\1");
        Matcher mc= pattern.matcher(test);
        while(mc.find()){
            System.out.println(mc.group());
     }

```



### 贪婪模式

1. 尽可能匹配更多

2. 多个贪婪在一起时，如果字符串能满足他们各自最大程度的匹配时，就互不干扰，但如果不能满足时，会根据深度优先原则，也就是从左到右的每一个贪婪量词，优先最大数量的满足，剩余再分配下一个量词匹配。

   例子

   ```
   \d{3,6}
   ```

   ```
   String reg = "\\d{3,6}";
   String test = "61762828 176 2991 871";
   System.out.println("文本：" + test);
   System.out.println("贪婪模式：" + reg);
   Pattern p1 = Pattern.compile(reg);
   Matcher m1 = p1.matcher(test);
   while (m1.find()) {
       System.out.println("匹配结果：" + m1.group(0));
   }
   
   文本：61762828 176 2991 871
   贪婪模式：\d{3,6}
   匹配结果：617628
   匹配结果：176
   匹配结果：2991
   匹配结果：871
   ```

   ```
   String reg = "\\d{1,2}\\d{3,4}";
   String test = "61762828 176 2991 87321";
   System.out.println("文本：" + test);
   System.out.println("贪婪模式：" + reg);
   Pattern p1 = Pattern.compile(reg);
   Matcher m1 = p1.matcher(test);
   while (m1.find()) {
       System.out.println("匹配结果：" + m1.group());
   }
   文本：61762828 176 2991 87321
   贪婪模式：\d{1,2}\d{3,4}
   匹配结果：617628
   匹配结果：2991
   匹配结果：87321
   
   1.第一次匹配到61 后面匹配到7628
   2.第一次匹配到2 后面匹配到299
   3.第一次匹配到87 后面匹配到321
   ```

   

### 懒惰模式 

1. 尽可能匹配最少
2. 懒惰量词是在贪婪量词后面加个"?"

|  代码  |              说明               |
| :----: | :-----------------------------: |
|  *？   |    重复任意次,但尽可能少重复    |
|  +？   | 重复1次或更多次，但尽可能少重复 |
|   ??   |  重复0次或1次，但尽可能少重复   |
| {n,}?  |   重复n次以上，但尽可能少重复   |
| {n,m}? |   重复n到m次，但尽可能少重复    |

```
String reg = "\\d{1,2}?\\d{3,4}";
String test = "61762828 176 2991 87321";
System.out.println("文本：" + test);
System.out.println("贪婪模式：" + reg);
Pattern p1 = Pattern.compile(reg);
Matcher m1 = p1.matcher(test);
while (m1.find()) {
    System.out.println("匹配结果：" + m1.group());
}
文本：61762828 176 2991 87321
贪婪模式：\d{1,2}?\d{3,4}
匹配结果：61762
匹配结果：2991
匹配结果：87321
1.第一次匹配到6 后面的贪婪匹配到1763
2.第一匹配到2  后面的贪婪匹配到991
3.第一次匹配到8 后面的贪婪匹配到7321
```

### 反义

1. 前面说到元字符的都是要匹配什么什么，当然如果你想反着来，不想匹配某些字符，正则也提供了一些常用的反义元字符：

2. | 元字符  |                  解释                  |
   | :-----: | :------------------------------------: |
   |   \W    | 匹配不是字母，数字，下划线，汉字的字符 |
   |   \S    |          匹配不是空白符的字符          |
   |   \D    |            匹配非数字的字符            |
   |   \B    |      匹配不是单词开头或结束的位置      |
   |  [^x]   |           匹配除了以外的字符           |
   | [^llol] |    匹配除lol这个几个字符以外的字符     |

   

